"""Provides thin-plate splines related operations and algorithms.
"""

import numpy as np
import math
import morphops.lmk_util as lmk_util
import warnings

def K_matrix(X, Y=None):
    """Calculates the upper-right (p,p) submatrix of the (p+k+1,p+k+1)-shaped 
    L matrix.

    Parameters
    ----------
    X : (p,2) or (p,3) shaped array-like

        A (p,k) array of p landmarks in k=2 or k=3 dimensions for one specimen.

    Y : (p,2) or (p,3) shaped array-like, optional

        A (p,k) array of p landmarks in k=2 or k=3 dimensions for one specimen. 
        `Y` must have the same k as X (but can have a different p).
    """
    num_coords = lmk_util.num_coords(X)
    if (num_coords != 2) and (num_coords != 3):
        raise ValueError("The input matrix must have landmarks with "
                         "coordinates in either 2 or 3 dimensions.")
    if Y is None:
        Y = X
    r = lmk_util.distance_matrix(X, Y)
    if (num_coords == 2):
        r_sqd = np.square(r)
        # Make a copy of r_sqd where 0->1. This copy will be passed to log.
        # This way log(1) will be 0 and we wont get NaN and warnings. 
        r_sqd_cl = np.copy(r_sqd)
        r_sqd_cl[np.isclose(r_sqd_cl,0)] = 1
        return -np.multiply(r_sqd, np.log(r_sqd_cl))
    # else num_coords is 3
    return -r

def P_matrix(X):
    """Makes the minor diagonal submatrix P of the (p+k+1,p+k+1)-shaped L 
    matrix.
    """
    ones = np.ones(lmk_util.num_lmks(X))
    return np.column_stack((ones, X))

def L_matrix(X):
    """Makes the (p+k+1,p+k+1)-shaped L matrix that gets inverted when 
    calculating the thin-plate spline "over" or "from" `X`.
    """
    n_coords = lmk_util.num_coords(X)
    n_lmks = lmk_util.num_lmks(X)
    K = K_matrix(X)
    P = P_matrix(X)
    L = np.zeros((n_lmks + n_coords + 1, n_lmks + n_coords + 1))
    L[0:n_lmks,0:n_lmks] = K
    L[0:n_lmks,n_lmks:] = P
    L[n_lmks:,0:n_lmks] = np.transpose(P)
    return L

def tps_coefs(X, Y):
    """Finds the tps coefficients for the tps function that interpolates from X 
    to Y.
    """
    n_coords = lmk_util.num_coords(X)
    n_lmks = lmk_util.num_lmks(X)
    V = np.row_stack((Y, np.zeros((n_coords+1,n_coords))))
    L = L_matrix(X)
    L_inv = np.linalg.inv(L)
    Q = np.matmul(L_inv, V)
    # return W and A.
    return Q[0:n_lmks], Q[n_lmks:]

def tps_warp(X, Y, pts):
    """Maps points `pts` to their image under the tps function generated by 
    :func:`tps_coefs` of `X` and `Y`.
    """
    W, A = tps_coefs(X, Y)
    U = K_matrix(pts, X)
    P = P_matrix(pts)
    # The warped pts are the affine part + the non-uniform part
    return np.matmul(P,A) + np.matmul(U,W)
    

